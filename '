pub const Entity = u32;

pub const World = struct {
    next_entity: Entity,
    gpa: mem.Allocator,
    archetypes: ArchetypeHashMap,
    entity_archetype: EntityArchetypeHashMap,

    const Self = @This();
    const ArchetypeHashMap = std.AutoHashMap(u64, Archetype);
    const EntityArchetypeHashMap = std.AutoArrayHashMap(Entity, u64);

    pub fn init(gpa: mem.Allocator) !Self {
        return .{
            .next_entity = 0,
            .archetypes = ArchetypeHashMap.init(gpa),
            .entity_archetype = EntityArchetypeHashMap.init(gpa),
            .gpa = gpa,
        };
    }

    pub fn spawn(self: *Self, components: anytype) !Entity {
        if (!util.isTuple(components))
            @compileError("expected tuple as argument");

        const types = util.typesOfTuple(components);
        const arch = try self.getOrCreateArchetype(.from(types));
        try arch.append(self.gpa, components);

        const e = self.next_entity;
        try self.entity_archetype.put(e, arch.hash);

        self.next_entity += 1;

        return e;
    }

    fn getOrCreateArchetype(self: *Self, meta: Archetype.Meta) !Archetype {
        const hash = meta.hash();
        if (self.archetypes.get(hash)) |arch| return arch;
        const arch = try Archetype.init(self.gpa, meta);
    }
};

const std = @import("std");
const mem = std.mem;
const testing = std.testing;
const assert = std.debug.assert;

const util = @import("util.zig");
const Archetype = @import("archetype.zig").Archetype;
